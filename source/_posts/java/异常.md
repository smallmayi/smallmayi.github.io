# springboot 全局异常处理和统一响应对象

## springboot异常处理

###　SpringBoot 默认的异常处理机制

默认情况，SpringBoot 提供两种不同响应方式

1. 一种是浏览器客户端请求一个不存在的页面或服务端异常时，SpringBoot默认会响应一个`html`

   ![image-20210811151827751](https://gitee.com/rainscloud/note-images/raw/master/img/20210812093816.png)

2. 另一种是使用`postman`等调试工具请求不存在的url或服务端异常时，默认返回json信息![image-20210811152000815](https://gitee.com/rainscloud/note-images/raw/master/img/20210811152000.png)

### SpringBoot 全局异常处理

一般我们不会将错误信息返回前端，自己去`try catch`捕获异常,但有个问题：每个方法都这样捕获异常，肯定是不合适，这是我们就需要全局的异常处理了。

```java
@RestController
public class ExceptionController {
    @GetMapping("exceptionA")
    public void methodA() {
        try {
            int a = 100 / 0;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 1. 局部异常处理

   使用`@EceptionHandle`注解实现某个类的局部异常处理

   ```java
   @RestController
   public class ExceptionController {
   
       @GetMapping("exceptionA")
       public void methodA() {
           int a = 100 / 0;
       }
   
       /**
        * 局部异常处理
        */
       @ExceptionHandler(Exception.class)
       public String exHandler(Exception e) {
           // 判断发生异常的类型是除0异常则做出响应
           if (e instanceof ArithmeticException) {
               return "发生了除0异常";
           }
           // 未知的异常做出响应
           return "发生了未知异常";
       }
   }
   ```

   ![image-20210811155022442](https://gitee.com/rainscloud/note-images/raw/master/img/20210811155022.png)

#### 2. 全局异常处理

   使用`@ControllerAdvice` +` @ExceptionHandler`注解实现全局异常处理

自定义一个异常类

```java
@RestControllerAdvice
public class DefaultException {

    @ExceptionHandler({NullPointerException.class})
    public String exception(NullPointerException exception) {
        return "空指针异常";

    }

    @ExceptionHandler({IndexOutOfBoundsException.class})
    public String exception(IndexOutOfBoundsException exception) {
        return "数组越界异常";
    }
}
```

增加一个异常方法测试，由于局部异常优先级更高先注释掉了

```java
@RestController
public class ExceptionController {

    @GetMapping("exceptionA")
    public void methodA() {
        int a = 100 / 0;
    }

    @GetMapping("exceptionB")
    public void methodB() {
        List list = new ArrayList<>();
        System.out.println(list.get(0));
    }

    /**
     * 局部异常处理
     */
    //@ExceptionHandler(Exception.class)
    //public String exHandler(Exception e) {
    //    // 判断发生异常的类型是除0异常则做出响应
    //    if (e instanceof ArithmeticException) {
    //        return "发生了除0异常";
    //    }
    //    // 未知的异常做出响应
    //    return "发生了未知异常";
    //}
}
```

![image-20210811161945540](https://gitee.com/rainscloud/note-images/raw/master/img/20210811161945.png)

全局异常注解已生效

### 自定义异常

自定义异常只需要继承`exception`类或其子类

```java
@Data
@NoArgsConstructor
public class CustomException extends Exception {

    private static final long serialVersionUID = 1L;

    private Integer code;

    private String mes;

    /**
     * @param code 状态码
     * @param msg  异常返回信息
     * @description 构造器
     */
    public CustomException(Integer code, String msg) {
        super(msg);
        this.code = code;
    }
}
```

使用时可以直接抛出异常对象

```java
@GetMapping("exceptionC")
public void methodC() throws CustomException {
    int a = 1;
    if (a == 1) {
        throw new CustomException(10086, "自定义异常");
    }
}
```



## 统一响应对象

实际开发中我们需要封装统一的响应对象，区分状态码和信息，以便前端处理。

### 定义统一的响应对象

一般包含状态码，错误信息，数据等。

自定义一些方法用来返回信息，比如我定义的success(),failed()方法

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class R<T> {
    /**
     * 返回状态码
     */
    private Integer code;
    /**
     * 返回信息
     */
    private String msg;
    /**
     * 数据
     */
    private T data;

    public static R success() {
        return new R(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMsg(), null);
    }

    public static R success(Object data) {
        return new R(ResultCode.SUCCESS.getCode(), ResultCode.SUCCESS.getMsg(), data);
    }

    public static R failed() {
        return new R(ResultCode.FAILED.getCode(), ResultCode.FAILED.getMsg(), null);
    }

    public static R failed(String msg) {
        return new R(ResultCode.FAILED.getCode(), msg, null);
    }

    public static R failed(int code, String msg) {
        return new R(code, msg, null);
    }
}
```

### 枚举信息

枚举一些常用的状态信息

我就举个例子，只枚举2个，根据需要去自定义

```java
@NoArgsConstructor
@AllArgsConstructor
public enum ResultCode {

    SUCCESS(200, "请求成功"),
    FAILED(500, "服务器错误");

    private int code;
    private String msg;

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

### 响应对象

使用时直接返回定义的对象类型就行了，将定义的全局异常返回类型也改成统一的响应对象

```java
@RestControllerAdvice
public class DefaultException {
    @ExceptionHandler({CustomException.class})
    public R exception(CustomException e) {
        return R.failed(e.getCode(),e.getMessage());
    }

    @ExceptionHandler({Exception.class})
    public R exception(Exception e) {
        return R.failed(e.getMessage());
    }
}
```

全局异常和响应对象的简单介绍就这样了，欢迎补充指正。

gitee地址：https://gitee.com/rainscloud/springboot-examples.git